# 91 解码方法

一条包含字母 A-Z 的消息通过以下方式进行了编码：

```
'A' -> 1
'B' -> 2
...
'Z' -> 26
```


给定一个只包含数字的非空字符串，请计算解码方法的总数。

##### 示例 1:

```
输入: "12"
输出: 2
解释: 它可以解码为 "AB"（1 2）或者 "L"（12）。
```

##### 示例 2:

```
输入: "226"
输出: 3
解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
```

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/decode-ways
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



##### 解法：

动态规划，可以看作有约束的爬楼梯问题。对于长度为 n 的字符串 `s`，用一个列表 `dp[n+1]` 保存结果。分情况讨论：

1. 若 s 为空或者第一个字符为 0 ，返回 0 。
2. 初始化 `dp` ，`dp[1]=1` 表示第一位的解码方法，`dp[0]=1` 用来统一递推公式，当字符串有两位时，如 `'12'` ，`dp[2]=dp[1]+dp[0]` 。
3. 从下标 1 开始遍历 s ：
   + 如果 `s[i]=='0'` ：因为 0 必须和前一位的 1 或 2 结果，所以当 `s[i-1]` 等于 1 或 2 时，解码长度和前前一位相同，`dp[i+1]=dp[i-1]` ，否则返回 0 无法解码。
   + 否则判断当前位是否能和前一位结合解码（爬楼梯问题）。如果可以结合，则当前解码数 `dp[i+1]` 等于结合情况的解码数 `dp[i-1]` 与不结合情况的解码数 `dp[i]` 的和。如果不能结合，解码数不变。
4. 返回结果 `dp[n]` 。

实际上结果只和前两位有关，不需要保存全部 `dp[n+1]` ，空间复杂度可以优化到 O(1)。

```python
class Solution:
    def numDecodings(self, s: str) -> int:
        if not s or s[0] == '0':
            return 0
        n = len(s)
        dp = [0] * (n + 1)
        dp[0] = 1
        dp[1] = 1
        for i in range(1, n):
            if s[i] == '0':
                if s[i-1] == '1' or s[i-1] == '2':
                    dp[i+1] = dp[i-1]
                else:
                    return 0
            else:
                if s[i-1] == '1' or (s[i-1] == '2' and s[i] <= '6'):
                    dp[i+1] = dp[i] + dp[i-1]
                else:
                    dp[i+1] = dp[i]
        return dp[-1]
```

