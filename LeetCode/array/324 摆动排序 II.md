# 324 摆动排序 II

给定一个无序的数组 nums，将它重新排列成 nums[0] < nums[1] > nums[2] < nums[3]... 的顺序。

##### 示例 1:

```
输入: nums = [1, 5, 1, 1, 6, 4]
输出: 一个可能的答案是 [1, 4, 1, 5, 1, 6]
```

##### 示例 2:

```
输入: nums = [1, 3, 2, 2, 3, 1]
输出: 一个可能的答案是 [2, 3, 1, 3, 1, 2]
```

##### 说明:

你可以假设所有输入都会得到有效的结果。

##### 进阶:

你能用 O(n) 时间复杂度和 / 或原地 O(1) 额外空间来实现吗？

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/wiggle-sort-ii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

##### 解法：

排序法：先对数组排序，然后把后半段穿插到前半段中，就得到一个摆动数列。

由于题目要求严格大于或小于，当有重复元素时，这个方法可能会出现问题，如数组 `[1,2,2,3]` 重组后结果还是一样。

分析一下可以发现，出现问题的重复元素 `r` 总是 **左子数列** 中最大的和 **右子数列** 中最小的，而且只有当 `r` 的个数等于 `len(nums)/2` 时才会相邻（如果 `r` 的个数更多则不存在有效解）。

只需要把两个子数列各自反转一下再穿插就可以解决。

```python
class Solution:
    def wiggleSort(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n = len(nums)
        if n < 2:
            return nums
        nums.sort()
        mid = n//2 if n % 2 == 0 else n//2+1  # 小子数列长度必须大于等于大子数列
        tmp1 = nums[mid-1::-1]
        tmp2 = nums[:mid-1:-1]
        for i in range(len(tmp1)):
            nums[2*i] = tmp1[i]
        for i in range(len(tmp2)):
            nums[2*i+1] = tmp2[i]
        return nums
```

实际上不需要对数组进行排序，我们只需要两边长度相同（或相差 1），而且左边的数总是小于等于右边即可。中间的重复元素 `r` 即为原数组的中位数。

利用快速排序思想先找到中位数，然后把小于 `r` 的数都放到左边，大于 `r` 的数都放到右边，然后按上面方法穿插即可。

这样问题就转化成 75 颜色分类和 215 数组中第 K 大元素。 