# 字符串匹配

字符串查找：在文本（主串）中找到一个和该模式（pattern）字符串相符的子字符串。

### BF算法

暴力搜索，假设文本长度为 n，模式长度为 m （一般情况下 n>m），那么时间复杂度为 $O(nm)$ 。

### RK算法

RK 算法的思路是这样的：我们通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。

### KMP算法

坏字符

好前缀

参考：

[1] 如何更好的理解和掌握 KMP 算法? - 知乎
https://www.zhihu.com/question/21923021

### BM算法

##### 坏字符规则（bad character rule）

##### 好后缀规则（good suffix shift）

### Sunday算法

在匹配失败时，关注主串中参加匹配的末位字符的下一位字符：

+ 如果该字符没有在模式串中出现，则直接跳过，即移动位数 = 模式串长度 + 1 。
+ 否则，移动位数 = 模式串长度 - 该字符最右出现的位置。

建立一个偏移表，记录移动位数。

LeetCode 28 字符串查找

```python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        m = len(haystack)
        n = len(needle)
        if not needle:
            return 0
        if n > m:
            return -1

        shift = {}  # 偏移表
        for i in range(n-1, -1, -1):
            if needle[i] not in shift:
                shift[needle[i]] = n - i
        shift['other'] = n + 1
        i = 0
        while i + n <= m:
            j = 0
            while needle[j] == haystack[i+j]:
                j += 1
                if j == n:
                    return i
            if i + n == m:
                return -1
            elif haystack[i + n] in shift:
                i += shift[haystack[i+n]]
            else:
                i += shift['other']
        return -1
```

参考：

[1] 字符串匹配算法之Sunday算法 - 简书
https://www.jianshu.com/p/2e6eb7386cd3

